
#include "EasyWinTasks.h"

//#include <ole2.h>
//#include <msterr.h>
//#include <wchar.h>
#include <sstream>

#include <iostream> //for debug

#define COR_E_FILENOTFOUND -2147024894
    //source: https://learn.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.vsconstants.cor_e_filenotfound?view=visualstudiosdk-2022



namespace EasyWin {
using namespace std;

//helper method - allows use of auto_ptr_x with LPWSTR pointers
void CoTaskMemStringCleanup(wchar_t * s)
{
	CoTaskMemFree(s);
}


//TODO - add delete method for task in scheduler
//TODO - add a function to get trigger by id - would simplify ensureschedtask
//TODO - add support for more schedule types to TaskTriggerTiming

/////////////////////////////
//SCHEDULER IMPLEMENTATIONS//
/////////////////////////////

Scheduler::Scheduler()
{
	HRESULT hr = S_OK;
	m_pTS = NULL;
	hr = CoCreateInstance(CLSID_CTaskScheduler,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_ITaskScheduler,
							(void **) &m_pTS);
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to create ITaskScheduler Interface", hr);
	}
}

Scheduler::Scheduler(const Scheduler & copied):
	m_pTS(copied.GetITaskScheduler())
{}

Scheduler::~Scheduler()
{
	Release();
}

Scheduler & Scheduler::operator=(const Scheduler & copied)
{
	Release();
	m_pTS = copied.GetITaskScheduler();
	return *(this);
}

ITaskScheduler * Scheduler::GetITaskScheduler() const
{
	if (m_pTS)
	{
		m_pTS->AddRef();
	}
	return m_pTS;
}

void Scheduler::Release()
{
	if (m_pTS)
	{
		m_pTS->Release();
		m_pTS=NULL;
	}
}

//very simple string array class providing auto-cleanup for the arrays generated by IEnumWorkItems::Next
struct TaskStringArray
{
	LPWSTR * array;
	DWORD size;

	void free()
	{
		if (array)
		{
			while (size)
			{
				--size;
				CoTaskMemFree(array[size]);
			}
			CoTaskMemFree(array);
		}
	}

	TaskStringArray(): array(NULL), size(0)
		{}

	~TaskStringArray()
	{
		free();
	}
};

//enum object needs freeing, CoTaskMemFrees not called in case of exception
void Scheduler::GetTaskNames(vector<wstring>& taskNames)
{
	AssertValid();
	HRESULT hr = S_OK;
	IEnumWorkItems * iEnum = NULL;
	hr = m_pTS->Enum(&iEnum);
	if (FAILED(hr) || !iEnum)
	{
		throw SchedulerException("Failed to create IEnumWorkItems interface to enumerate scheduled tasks", hr);
	}
	AutoIUnknownPtr iEnumCleanup(iEnum);

	TaskStringArray namesBatch;
	while (SUCCEEDED(iEnum->Next(BATCH_TO_RETRIEVE, &(namesBatch.array), &(namesBatch.size)))
							&& (namesBatch.size != 0))
		//note have checked that when namesBatch.size == 0, namesBatch.array == NULL
	{
		for (DWORD i = 0; i < namesBatch.size; i++)
		{
			wstring name((LPWSTR)(namesBatch.array)[i]);
			taskNames.push_back(name);
		}
		namesBatch.free();
	}
}


void Scheduler::GetTasks(std::vector<Task>& tasks, TaskStatus status)
{
	vector<wstring> taskNames;
	GetTaskNames(taskNames);
	for(vector<wstring>::iterator i = taskNames.begin(); i != taskNames.end(); ++i)
	{
		Task task = GetTask(*i);
		if (status == ANY || task.GetStatus() == status)
		{
			tasks.push_back(task);
		}
	}
}


//questionable design decision to return invalid task if task not found
//	maybe better to throw exception and have separate TaskExists method
Task Scheduler::GetTask(const std::wstring & taskName)
{
	AssertValid();
	IUnknown * iTask = NULL;
	HRESULT hr = m_pTS->Activate(taskName.c_str(), IID_ITask , &iTask);
	if (hr == COR_E_FILENOTFOUND) //if the task does not exist
	{
		return Task();
	}
	else if (FAILED(hr) || !iTask) //on any other failure
	{
		throw SchedulerException("Failed to read a scheduled task", hr);
	}
	else
	{
		return Task((ITask *) iTask, taskName);
	}
}


//note if another task of same name created before save our task, saving will fail - could avoid this by using AddWorkItem
Task Scheduler::NewTask(const std::wstring & taskName)
{
	HRESULT hr;
	ITask * pITask = NULL;
	hr = m_pTS->NewWorkItem(taskName.c_str(), CLSID_CTask, IID_ITask, (IUnknown**)& pITask);
	if (FAILED(hr))
	{
		wstring message(L"Task name: ");
		message += taskName;
		throw SchedulerException("Failed to create new task", hr, message);
	}
	return Task(pITask, taskName);
}

void Scheduler::AssertValid() const
{
	if (!m_pTS)
	{
		throw SchedulerException("Program Bug - attempt to use an invalid Scheduler object");
	}
}


////////////////////////
//TASK IMPLEMENTATIONS//
////////////////////////


Task::Task(): m_pITask(NULL), m_name(L"")
{}

Task::Task(ITask * pITask, const wstring & name): m_pITask(pITask), m_name(name)
{}

Task::Task(const Task & copied): m_pITask(copied.GetITask()), m_name(copied.m_name)
{}

Task::~Task()
{
	Release();
}

Task & Task::operator=(const Task & copied)
{
	Release();
	m_pITask = copied.GetITask();
	m_name = copied.m_name;
	return *(this);
}

ITask * Task::GetITask() const
{
	if (m_pITask)
	{
		m_pITask->AddRef();
	}
	return m_pITask;
}

void Task::Release()
{
	if (m_pITask)
	{
		m_pITask->Release();
		m_pITask=NULL;
		m_name = L"";
	}
}

bool Task::IsValid() const
{
	return m_pITask != NULL;
}

wstring Task::GetName() const
{
	return m_name;
}


TaskStatus Task::GetStatus() const
{
	AssertValid();
	HRESULT status = 0;
	HRESULT hr = m_pITask->GetStatus(&status);
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to get task status", hr);
	}
	return (TaskStatus) status;
}



//http://msdn.microsoft.com/en-us/library/aa381830(VS.85).aspx
//http://msdn.microsoft.com/en-us/library/ms693701(VS.85).aspx
//http://msdn.microsoft.com/en-us/library/aa446829(VS.85).aspx
void Task::Save()
{
	IPersistFile * pIPersistFile = NULL;
	HRESULT hr = m_pITask->QueryInterface(IID_IPersistFile, (void **) &pIPersistFile);
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to save task to file: failed to get IPersistFile interface", hr);
	}
	hr = pIPersistFile->Save(NULL, TRUE);
	pIPersistFile->Release();
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to save task to file", hr);
	}
}

WORD Task::GetTriggerCount() const
{
	AssertValid();
	WORD count = 0;
	HRESULT hr = m_pITask->GetTriggerCount(&count);
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to get count of task triggers", hr);
	}
	return count;
}

void Task::GetTriggers(vector<TaskTrigger>& taskTriggers)
{
	AssertValid();
	HRESULT hr = 0;
	WORD numTriggers = GetTriggerCount();
	for(WORD i = 0; i < numTriggers; i++)
	{
		ITaskTrigger * trigger = NULL;
		hr = m_pITask->GetTrigger(i, &trigger);
		if (FAILED(hr))
		{
			throw SchedulerException("Failed to obtain a task's triggers", hr);
		}
		taskTriggers.push_back(TaskTrigger(trigger));
	}
}

TaskTrigger Task::CreateTrigger(WORD & triggerIndex)
{
	AssertValid();
	WORD aTriggerIndex;
	ITaskTrigger * pITrigger = NULL;
	HRESULT hr = m_pITask->CreateTrigger(&aTriggerIndex, &pITrigger);
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to create new trigger for task", hr);
	}
	triggerIndex = aTriggerIndex;
	return TaskTrigger(pITrigger);
}

TaskTrigger Task::CreateTrigger()
{
	WORD triggerIndex;
	return CreateTrigger(triggerIndex);
}

void Task::DeleteTrigger(WORD triggerIndex)
{
	AssertValid();
	HRESULT hr = m_pITask->DeleteTrigger(triggerIndex);
	if (FAILED(hr))
	{
		ostringstream messageStream;
		messageStream << "Failed to delete task. Index: " << triggerIndex;
		throw SchedulerException(messageStream.str(), hr);
	}
}

//this function needs more testing - not sure comparison effective
void Task::DeleteTrigger(TaskTrigger trigger)
{
	AssertValid();
	HRESULT hr = 0;
	WORD numTriggers = GetTriggerCount();
	WORD i = 0;
	bool done = false;
	while (i < numTriggers && !done)
	{
		ITaskTrigger * testTrigger = NULL;
		hr = m_pITask->GetTrigger(i, &testTrigger);
		if (FAILED(hr))
		{
			ostringstream messageStream;
			messageStream << "Failed to read one of the task triggers being tested to find trigger to delete. Index: " << i;
			throw SchedulerException(messageStream.str(), hr);
		}
		AutoIUnknownPtr testTriggerCleanup(testTrigger);

		if (testTrigger == trigger.m_pITaskTrigger) //if we've found the trigger to delete
		{
			DeleteTrigger(i);
		}
		++i;
	}
}

void Task::DeleteAllTriggers()
{
	while (GetTriggerCount() > 0)
	{
		DeleteTrigger(0);
	}
}



void Task::SetApplicationName(wstring applicationName)
{
	AssertValid();
	HRESULT hr = m_pITask->SetApplicationName(applicationName.c_str());
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to set application name of task", hr, applicationName);
	}
}

wstring Task::GetApplicationName() const
{
	AssertValid();
	LPWSTR appName = NULL;
	HRESULT hr = m_pITask->GetApplicationName(&appName);
	if (FAILED(hr) || !appName)
	{
		throw SchedulerException("Failed to get application name of task", hr);
	}
	auto_ptrx<wchar_t, CoTaskMemStringCleanup> appNameCleanup(appName);
	return wstring(appName);
}

void Task::SetWorkingDirectory(wstring workingDir)
{
	AssertValid();
	HRESULT hr = m_pITask->SetWorkingDirectory(workingDir.c_str());
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to set working directory of task", hr, workingDir);
	}
}

wstring Task::GetWorkingDirectory() const
{
	AssertValid();
	LPWSTR workDir = NULL;
	HRESULT hr = m_pITask->GetWorkingDirectory(&workDir);
	if (FAILED(hr) || !workDir)
	{
		throw SchedulerException("Failed to get working directory of task", hr);
	}
	auto_ptrx<wchar_t, CoTaskMemStringCleanup> workDirCleanup(workDir);
	return wstring(workDir);
}

void Task::SetAccountInformation(wstring userName, wstring password)
{
	AssertValid();
	LPCWSTR passwordArg = ((userName==L"") ? NULL : password.c_str());
	HRESULT hr = m_pITask->SetAccountInformation(userName.c_str(), passwordArg);
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to set task account information", hr, userName);
			//do not state password in exception for security reasons
	}
}

wstring Task::GetAccountName() const
{
	AssertValid();
	LPWSTR accountName = NULL;
	HRESULT hr = m_pITask->GetAccountInformation(&accountName);
	if (FAILED(hr) || !accountName)
	{
		throw SchedulerException("Failed to get account name of scheduled task", hr);
	}
	auto_ptrx<wchar_t, CoTaskMemStringCleanup> accountNameCleanup(accountName);
	return wstring(accountName);
}

void Task::SetParameters(wstring parameters)
{
	AssertValid();
	HRESULT hr = m_pITask->SetParameters(parameters.c_str());
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to set command line parameters of scheduled task", hr, parameters);
	}
}

wstring Task::GetParameters() const
{
	AssertValid();
	LPWSTR parameters = NULL;
	HRESULT hr = m_pITask->GetParameters(&parameters);
	if (FAILED(hr) || !parameters)
	{
		throw SchedulerException("Failed to get command line parameters of scheduled task", hr);
	}
	auto_ptrx<wchar_t, CoTaskMemStringCleanup> parametersCleanup(parameters);
	return wstring(parameters);
}

void Task::SetFlags(DWORD flags)
{
	AssertValid();
	HRESULT hr = m_pITask->SetFlags(flags);
	if (FAILED(hr))
	{
		wstringstream s;
		s << L"Specified flags: " << flags;
		throw SchedulerException("Failed to set options for scheduled task", hr, s.str());
	}
}

DWORD Task::GetFlags() const
{
	AssertValid();
	DWORD flags = 0;
	HRESULT hr = m_pITask->GetFlags(&flags);
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to get options set for scheduled task", hr);
	}
	return flags;
}

void Task::SetMaxRunTime(DWORD millisecondsRunTime)
{
	AssertValid();
	HRESULT hr = m_pITask->SetMaxRunTime(millisecondsRunTime);
	if (FAILED(hr))
	{
		wstringstream s;
		s << L"Specified maximum run time: " << millisecondsRunTime;
		throw SchedulerException("Failed to set maximum allowed run time for scheduled task", hr, s.str());
	}
}

DWORD Task::GetMaxRunTime() const
{
	AssertValid();
	DWORD maxRunTime = 0;
	HRESULT hr = m_pITask->GetMaxRunTime(&maxRunTime);
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to get maximum allowed run time for scheduled task", hr);
	}
	return maxRunTime;
}

void Task::Run()
{
	AssertValid();
	HRESULT hr = m_pITask->Run();
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to run task", hr);
	}
}

void Task::Terminate()
{
	AssertValid();
	HRESULT hr = m_pITask->Terminate();
	if (FAILED(hr))
	{
		throw SchedulerException("Failed to terminate task", hr);
	}
}


const wstring Task::SYSTEM_ACCOUNT_NAME = L"";

std::wostream & operator<< (std::wostream & out, const Task & task)
{
	out << task.GetName();
	return out;
}

void Task::AssertValid() const
{
	if (!m_pITask)
	{
		throw SchedulerException("Program Bug - attempt to use an invalid Task object");
	}
}


///////////////////////////////
//TASKTRIGGER IMPLEMENTATIONS//
///////////////////////////////

TaskTrigger::TaskTrigger(): m_pITaskTrigger(NULL)
{}

TaskTrigger::TaskTrigger(ITaskTrigger * pITaskTrigger): m_pITaskTrigger(pITaskTrigger)
{}

TaskTrigger::TaskTrigger(const TaskTrigger & copied): m_pITaskTrigger(copied.GetITaskTrigger())
{}

TaskTrigger::~TaskTrigger()
{
	Release();
}

TaskTrigger & TaskTrigger::operator=(const TaskTrigger & copied)
{
	Release();
	m_pITaskTrigger = copied.GetITaskTrigger();
	return *(this);
}

void TaskTrigger::Set(const TASK_TRIGGER & triggerStruct)
{
	AssertValid();
	HRESULT hr = m_pITaskTrigger->SetTrigger((const PTASK_TRIGGER)&triggerStruct);
	if (FAILED(hr))
	{
		throw SchedulerException("Unable to set trigger for scheduled task", hr);
	}
}

void TaskTrigger::Set(const TaskTriggerTiming & triggerTiming)
{
	Set(triggerTiming.GetTASK_TRIGGER());
}

bool TaskTrigger::HasEquivalentTiming(const TaskTriggerTiming & timing)
{
	TASK_TRIGGER trigStruct = GetTriggerStruct();
	return timing.Equivalent(TaskTriggerTiming(trigStruct));
}


TASK_TRIGGER TaskTrigger::GetTriggerStruct() const
{
	AssertValid();

	TASK_TRIGGER trigger;
	trigger.cbTriggerSize = sizeof(trigger);
	HRESULT hr = m_pITaskTrigger->GetTrigger(&trigger);
	if (FAILED(hr))
	{
		throw SchedulerException("Unable to read trigger details for scheduled task", hr);
	}
	return trigger;
}

std::wstring TaskTrigger::GetTriggerString() const
{
	AssertValid();

	LPWSTR triggerStr = NULL;
	HRESULT hr = m_pITaskTrigger->GetTriggerString(&triggerStr);
	if (FAILED(hr))
	{
		throw SchedulerException("Unable to obtain string describing trigger details for scheduled task", hr);
	}
	auto_ptrx<wchar_t, CoTaskMemStringCleanup> triggerStrCleanup(triggerStr);
	return wstring(triggerStr);
}

ITaskTrigger * TaskTrigger::GetITaskTrigger() const
{
	if (m_pITaskTrigger)
	{
		m_pITaskTrigger->AddRef();
	}
	return m_pITaskTrigger;
}

void TaskTrigger::Release()
{
	if (m_pITaskTrigger)
	{
		m_pITaskTrigger->Release();
		m_pITaskTrigger=NULL;
	}
}

void TaskTrigger::AssertValid() const
{
	if (!m_pITaskTrigger)
	{
		throw SchedulerException("Program Bug - attempt to use an invalid TaskTrigger object");
	}
}


/////////////////////////////////////
//TaskTriggerTiming IMPLEMENTATIONS//
/////////////////////////////////////

TaskTriggerTiming::TaskTriggerTiming()
{
	ZeroMemory(&m_trigStruct, sizeof(m_trigStruct));
	m_trigStruct.cbTriggerSize = sizeof(m_trigStruct);
}

TaskTriggerTiming::TaskTriggerTiming(const TASK_TRIGGER & trigStruct):
	m_trigStruct(trigStruct)
{}

void TaskTriggerTiming::SetDaily(WORD startHour, WORD startMinute, WORD daysInterval)
{
	SYSTEMTIME systemTime, localTime;
    GetSystemTime(&systemTime);
    GetLocalTime(&localTime);

	ZeroMemory(&m_trigStruct, sizeof(m_trigStruct));
	m_trigStruct.cbTriggerSize = sizeof(m_trigStruct);
	m_trigStruct.wBeginYear = localTime.wYear; //local time years are since 1900
	m_trigStruct.wBeginMonth = localTime.wMonth; //both SYSTEMTIME and TASK_TRIGGER month values indexed from 1
	m_trigStruct.wBeginDay = localTime.wDay; //both SYSTEMTIME and TASK_TRIGGER day values indexed from 1
	//DEBUG - cout << m_trigStruct.wBeginYear << " " << m_trigStruct.wBeginMonth << " " << m_trigStruct.wBeginDay << endl;
	m_trigStruct.wStartHour = startHour;
	m_trigStruct.wStartMinute = startMinute;
	m_trigStruct.TriggerType = TASK_TIME_TRIGGER_DAILY;
	m_trigStruct.Type.Daily.DaysInterval = daysInterval;
}

void TaskTriggerTiming::AddRepeats(DWORD minutesInterval, DWORD minutesDuration, bool killAtEndDuration)
{
	if (minutesInterval >= minutesDuration)
	{
		wstringstream s;
		s << L"Duration in minutes: " << minutesDuration;
		s << L", Interval of repeats in minutes: " << minutesInterval;
		throw SchedulerException("The duration specified for task to repeat is not greater than the specified interval of repeats.", ERROR_INVALID_PARAMETER, s.str());
	}

	m_trigStruct.MinutesInterval = minutesInterval;
	m_trigStruct.MinutesDuration = minutesDuration;
	if (killAtEndDuration)
	{
		m_trigStruct.rgFlags = m_trigStruct.rgFlags | TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
	}
	else
	{
		m_trigStruct.rgFlags = m_trigStruct.rgFlags & ~TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
	}
}

DWORD TaskTriggerTiming::GetRepeatInterval()
{
	return m_trigStruct.MinutesInterval;
}

DWORD TaskTriggerTiming::GetRepeatDuration()
{
	return m_trigStruct.MinutesDuration;
}

bool TaskTriggerTiming::operator==(const TaskTriggerTiming & other) const
{
	return EqualExceptBeginAndEndDay(other)
				&& (m_trigStruct.wBeginYear == other.m_trigStruct.wBeginYear)
				&& (m_trigStruct.wBeginMonth == other.m_trigStruct.wBeginMonth)
				&& (m_trigStruct.wBeginDay == other.m_trigStruct.wBeginDay)
				&& (m_trigStruct.wEndYear == other.m_trigStruct.wEndYear)
				&& (m_trigStruct.wEndMonth == other.m_trigStruct.wEndMonth)
				&& (m_trigStruct.wEndDay == other.m_trigStruct.wEndDay);
}

bool TaskTriggerTiming::Equivalent(const TaskTriggerTiming & other) const
{
	return EqualExceptBeginAndEndDay(other)
		&& HasEquivalentBeginDay(other)
		&& HasEquivalentEndDay(other);
}

bool TaskTriggerTiming::EqualExceptBeginAndEndDay(const TaskTriggerTiming & other) const
{
	bool equal = (m_trigStruct.cbTriggerSize == other.m_trigStruct.cbTriggerSize)
				&& (m_trigStruct.MinutesDuration == other.m_trigStruct.MinutesDuration)
				&& (m_trigStruct.MinutesInterval == other.m_trigStruct.MinutesInterval)
				&& (m_trigStruct.rgFlags == other.m_trigStruct.rgFlags)
				&& (m_trigStruct.TriggerType == other.m_trigStruct.TriggerType);

	if (m_trigStruct.TriggerType != TASK_EVENT_TRIGGER_ON_IDLE) //wStartHour and wStartMinute ignored for triggers of this type
	{
		equal = equal && (m_trigStruct.wStartHour == other.m_trigStruct.wStartHour)
				&& (m_trigStruct.wStartMinute == other.m_trigStruct.wStartMinute);
	}

	switch (m_trigStruct.TriggerType)
	{
		case TASK_TIME_TRIGGER_DAILY:
			equal = equal && (m_trigStruct.Type.Daily.DaysInterval==other.m_trigStruct.Type.Daily.DaysInterval);
		break;
		case TASK_TIME_TRIGGER_WEEKLY:
			equal = equal && (m_trigStruct.Type.Weekly.WeeksInterval==other.m_trigStruct.Type.Weekly.WeeksInterval)
							&& (m_trigStruct.Type.Weekly.rgfDaysOfTheWeek==other.m_trigStruct.Type.Weekly.rgfDaysOfTheWeek);
		break;
		case TASK_TIME_TRIGGER_MONTHLYDATE:
			equal = equal && (m_trigStruct.Type.MonthlyDate.rgfDays == other.m_trigStruct.Type.MonthlyDate.rgfDays)
							&& (m_trigStruct.Type.MonthlyDate.rgfMonths == other.m_trigStruct.Type.MonthlyDate.rgfMonths);
		break;
		case TASK_TIME_TRIGGER_MONTHLYDOW:
			equal = equal && (m_trigStruct.Type.MonthlyDOW.wWhichWeek == other.m_trigStruct.Type.MonthlyDOW.wWhichWeek)
							&& (m_trigStruct.Type.MonthlyDOW.rgfDaysOfTheWeek == other.m_trigStruct.Type.MonthlyDOW.rgfDaysOfTheWeek)
							&& (m_trigStruct.Type.MonthlyDOW.rgfMonths == other.m_trigStruct.Type.MonthlyDOW.rgfMonths);
		break;
		case TASK_TIME_TRIGGER_ONCE:
		case TASK_EVENT_TRIGGER_ON_IDLE:
		case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
		case TASK_EVENT_TRIGGER_AT_LOGON:
		;//do nothing
	}

	return equal;
}

const TASK_TRIGGER & TaskTriggerTiming::GetTASK_TRIGGER() const
{
	return m_trigStruct;
}

//return whether day1 in month1 in year1 is before or equal to day2 in month2 in year2
bool YMDBeforeOrEqual(WORD year1, WORD month1, WORD day1, WORD year2, WORD month2, WORD day2)
{
	bool itIs = false;
	if(year1 < year2)
	{
		itIs = true;
	}
	else if (year1 == year2)
	{
		if (month1 < month2)
		{
			itIs = true;
		}
		else if (month1 == month2)
		{
			if (day1 <= day2)
			{
				itIs = true;
			}
		}
	}

	return itIs;
}


bool TaskTriggerTiming::HasEquivalentBeginDay(const TaskTriggerTiming & other) const
{
	SYSTEMTIME systemTime, localTime;
    GetSystemTime(&systemTime);
    GetLocalTime(&localTime);

	if (YMDBeforeOrEqual(m_trigStruct.wBeginYear, m_trigStruct.wBeginMonth, m_trigStruct.wBeginDay,
						localTime.wYear, localTime.wMonth, localTime.wDay)
		&& YMDBeforeOrEqual(other.m_trigStruct.wBeginYear, other.m_trigStruct.wBeginMonth, other.m_trigStruct.wBeginDay,
						localTime.wYear, localTime.wMonth, localTime.wDay))
	{
		return true;
	}
	else
	{
		return m_trigStruct.wBeginYear == other.m_trigStruct.wBeginYear
			&& m_trigStruct.wBeginMonth == other.m_trigStruct.wBeginMonth
			&& m_trigStruct.wBeginDay == other.m_trigStruct.wBeginDay;
	}
}

bool TaskTriggerTiming::HasEquivalentEndDay(const TaskTriggerTiming & other) const
{
	SYSTEMTIME systemTime, localTime;
    GetSystemTime(&systemTime);
    GetLocalTime(&localTime);

	if (YMDBeforeOrEqual(m_trigStruct.wEndYear, m_trigStruct.wEndMonth, m_trigStruct.wEndDay,
						localTime.wYear, localTime.wMonth, localTime.wDay)
		&& YMDBeforeOrEqual(other.m_trigStruct.wEndYear, other.m_trigStruct.wEndMonth, other.m_trigStruct.wEndDay,
						localTime.wYear, localTime.wMonth, localTime.wDay))
	{
		return true;
	}
	else
	{
		return m_trigStruct.wEndYear == other.m_trigStruct.wEndYear
			&& m_trigStruct.wEndMonth == other.m_trigStruct.wEndMonth
			&& m_trigStruct.wEndDay == other.m_trigStruct.wEndDay;
	}
}


//////////////////////////////////////
//SchedulerException IMPLEMENTATIONS//
//////////////////////////////////////
WinException * SchedulerException::Clone() const
{
	return new SchedulerException(*this);
}


} //end namespace EasyWin


